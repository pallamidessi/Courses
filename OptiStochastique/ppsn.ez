
\User declarations :
  #define MAX_PAPERS 8
  #define PAP_KEYH 5
  #define PAP_AUTH 5
  #define PAP_INST 5

  #define MAX_REVIEWER 12
  #define REV_KEYW 5
  #define REV_WILL 5
  #define REV_UNWILL 5

  #define REV_PER_PAPER 3
  
  int PAPERS, REVIEWERS;

  struct PaperInfo {
    char title [50];
    int keyword [PAP_KEYH] ;
    char author [PAP_AUTH] [50] ;
    char institution [PAP_INST] [50] ;
  } PAPER[MAX_PAPERS];

  struct ReviewerInfo {
    char name [50];
    int keyword [REV_KEYW] ;
    char institution[50];
    int willing[REV_WILL];
    int unwilling[REV_UNWILL] ;
  } REVIEW[MAX_REVIEWER];


  float pMutPerGene = 0.3;
  FILE* fpPapers; 
  FILE* fpReviewers;
\end

\User functions:
  int mystricmp(char *string1, char *string2){
    int i = 0;

    for (i = 0 ; string1[i] && string2 [i] ; i++) {
      if (tolower(string1[i]) < tolower(string2[i] )) return - (i + 1);
      if (tolower(string1[i]) > tolower(string2[i] )) return i + 1;
    }

    if (string2[1]) return - (i + 1);
    if (string1[1]) return i + 1;

    return 0 ;
  }
\end

\User classes :

  Match {
    int reviewer[3];
  }

  GenomeClass {
    Match paper[8] ;
  }

\end


\Before everything else function:
  int i, j;

  fpPapers = fopen("Papers.txt", "r");
  fpReviewers = fopen("Review.txt", "r");
  
  /* Check if the data files are present or readable */
  if(fpPapers == NULL){
    std::cout << "Missing or error opening \"Papers.txt\". Exiting now." << std::endl;
    exit(1);
  }
  else if(fpReviewers == NULL){
    std::cout << "Missing or error opening \"Review.txt\". Exiting now." << std::endl;
    exit(1);
  }

  for (i = 0; i < MAX_PAPERS ; i++) {
    strcpy (PAPER[i].title, "");

    for (j = 0 ;  j <PAP_KEYH ; j++) 
      PAPER[i].keyword[j] = 999;

    for (j = 0 ;  j <PAP_AUTH ; j++)
      strcpy (PAPER[i].author[j], "");

    for (j = 0 ;  j <PAP_INST ; j++)
      strcpy (PAPER[i].institution [j] , "");
  }

  for (i = 0; i < MAX_REVIEWER; i++) {
    strcpy (REVIEW[i].name, "") ;

    for (j = 0 ; j < REV_KEYW ; j++) 
      REVIEW[i].keyword[j] = 999;

    strcpy (REVIEW[i].institution, "");

    for (j = 0; j < REV_WILL; j++)
      REVIEW[i].willing[j] = 999;

    for (j = 0; j < REV_UNWILL ; j++)
      REVIEW[i].unwilling [j] = 999;
  }

  for (i = 0; i < MAX_PAPERS; i++) {
    if (fscanf(fpPapers, "%[^\n]", PAPER[i].title) == EOF) 
      break; 

    getc(fpPapers) ;

    for (j = 0; j < PAP_KEYH; j++) {
      fscanf(fpPapers, "%d", &(PAPER[i].keyword[j]));

      if (getc(fpPapers) == '\n')
        break;
    }

    for (j = 0; j < PAP_AUTH; j++) {
      fscanf (fpPapers , "%[^,\n]", PAPER[i].author[j]);
      if (getc(fpPapers) == '\n') 
        break;
    }

    for (j = 0; j < PAP_INST; j++) {
      fscanf (fpPapers , "%[^,\n]", PAPER[i].institution[j]);
      if (getc(fpPapers) == '\n') 
        break;
    }
  }

  PAPERS = i;

  for (i = 0; i < MAX_REVIEWER; i++) {
    if (fscanf (fpReviewers , "%[^\n]", REVIEW[i].name) == EOF)
      break; 

    getc (fpReviewers);

    for (j = 0; j < REV_KEYW; j++) {
      fscanf(fpReviewers, "%d", &(REVIEW[i].keyword[j]));

      if (getc(fpReviewers) == '\n') 
        break;
    }

    fscanf(fpReviewers , "%[^\n]", REVIEW[i].institution);
    getc(fpReviewers);

    for (j = 0; j < REV_WILL; j++) {

      fscanf (fpReviewers, "%d", &(REVIEW[i].willing[j])) ;
      if (getc(fpReviewers) == '\n')
        break;
    }

    for (j = 0 ; j < REV_UNWILL; j++) {
      fscanf (fpReviewers , "%d" , &(REVIEW[i].unwilling[j])) ;
      if (getc(fpReviewers) == '\n') 
        break;
    }
  }

  REVIEWERS = i;

  fclose(fpPapers);
  fclose(fpReviewers);

\end 


\GenomeClass::initialiser : // "initializer" is also accepted
  int i, j, k, again = 0;

  for (i = 0; i < PAPERS; i++)
  for (j = 0; j < REV_PER_PAPER; j++)

  do {
    again = 0;
    Genome.paper[i].reviewer[j] = (int) random (0, REVIEWERS);

    for (k = 0 ; k < j ; k++) 
      if (Genome.paper[i].reviewer[k] == Genome.paper[i].reviewer[j])
        again++;

  } while (again) ;
\end


\GenomeClass::crossover :
int i, j;
int pos = (int) random(0, PAPERS - 1); // Picks a random site named pos

  for(i = pos; i < PAPERS; i++)
    for(j = 0; j < REV_PER_PAPER; j++)
      child.paper[i].reviewer[j] = parent2.paper[i].reviewer[j];
  
\end

\GenomeClass::mutator : // Must return the number of mutations
  int i, j, k, again, nbMut = 0;

  for (i = 0; i < PAPERS; i++){
    if (tossCoin(pMutPerGene)){
      for(j = 0; j < REV_PER_PAPER; j++)
        do {
          again = 0;
          Genome.paper[i].reviewer[j] = (int) random(0, REVIEWERS);
          for (k = 0; k < j; k++) 
            if (Genome.paper[i].reviewer[k] == Genome.paper[i].reviewer[j]) 
              again++;
        } while (again) ;

      nbMut++;
    }
  }

  return nbMut;
\end

\GenomeClass::evaluator : // Returns the score
  int i, j, k, l;
  int eval = 100000;
  int papPerRev[MAX_REVIEWER];

  for (i = 0; i < REVIEWERS; papPerRev[i++] = 0);
  for (i = 0; i < PAPERS; i++)
  for (j = 0; j < REV_PER_PAPER; j++){
    // if the keywords of the paper match the keywords of the reviewer
    for (k = 0 ; k < REV_KEYW; k++)
      for (l = 0; l < PAP_KEYH; l++)
        if ( (REVIEW[Genome.paper[i].reviewer[j]].keyword[k] == PAPER[i].keyword[l])
            &&(REVIEW[Genome.paper[i].reviewer[j]].keyword[k] != 999)
            &&(PAPER[i].keyword[l] != 999)
           ) eval++;

    // if paper and reviewer come from the same institution
    for (k = 0; k < PAP_INST; k++)
      if (!mystricmp(REVIEW[Genome.paper[i].reviewer[j]].institution, PAPER[i].institution[k])) 
        eval -= 1000;

    // if the reviewer has been willing to review the paper

    for(k = 0; k < REV_WILL; k++)
      if (REVIEW[Genome.paper[i].reviewer[j]].willing[k] == i)
        eval++;

    // if the reviewer has been unwilling to review the paper
    for (k = 0 ; k < REV_UNWILL; k++)
      if (REVIEW[Genome.paper[i].reviewer[j]].unwilling[k] == i) 
        eval--;

    // Reviewers should review have an average of REV_PER_PAPERXPAPERS/REVIEWER papers to review
    papPerRev[Genome.paper[i].reviewer[j]]++;

  }

  for (i = 0; i < REVIEWERS; i++) 
    eval -= abs(papPerRev[i] - REV_PER_PAPER*PAPERS/REVIEWERS);

  return (double) (eval < 0 ? 0 : eval);
\end

\User Makefile options: 
  CXXFLAGS += -Wno-unused-result
\end

\Default run parameters :        // Please let the parameters appear in this order
  Population size : 100 // PSize
  Number of generations : 100 // NbGen
  
  Mutation probability : 0.3 // PHut
  Crossover probability : 1 // PCross
  
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 2.0
  
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong			//Weak or Strong
  Elite: 1
  Print stats: true				//Default: 1
  Generate csv stats file: false			
  Generate gnuplot script: false
  Generate R script: false
  Plot stats: true				//Default: 0

  Remote island model: false
  IP file: ip.txt 			//File containing all the remote island's IP
  Server port : 2929
  Migration probability: 0.33

  Save population: false
  Start from file: false

\end
